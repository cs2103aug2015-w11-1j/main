# A0110616W
###### commandDetail\CommandDetails.java
``` java

import java.util.Date;
import task.Task;

/**
 * CommandDetails is a stand-alone object used in GetStuffDone
 * CommandDetails does not know the existence of GSDControl, Parser, History, Storage and UI
 * CommandDetails knows the existence of Task
 * 
 * INTERACTIONS OF CommandDetails WITH OTHER CLASSES:
 * 
 * GSDControl: Used by GSDControl to construct a Task object. Sent and received by GSDControl to and from History respectively
 * Task: Task is created by a CommandDetails object
 * Parser: Parses input commands into a CommandDetails object which is returned to GSDControl
 * History: Stores CommandDetails objects in its undoStack and redoStack
 */



public class CommandDetails {
	private Date deadline;
	private Date startDate;
	private String description;
	private COMMANDS command;
	private int ID;
	private Task oldTask;
	private Task newTask;

	public enum COMMANDS {
		ADD, DELETE, SEARCH, UPDATE, COMPLETE, INCOMPLETE, UNDO, REDO, HELP, ALL, 
		FLOATING, EVENTS, DEADLINES, EXIT, INVALID, SET,
	}

	// Constructors
	public CommandDetails(COMMANDS command, String description, Date startDate, 
			Date deadline, int ID) {
		this.deadline = deadline;
		this.startDate = startDate;
		this.description = description;
		this.command = command;
		this.ID = ID;

	}

	public CommandDetails(COMMANDS command, String description, Date startDate, 
			Date deadline, int ID, Task newTask) {
		this.deadline = deadline;
		this.startDate = startDate;
		this.description = description;
		this.command = command;
		this.ID = ID;
		this.newTask = newTask;
	}

	public CommandDetails(COMMANDS command, String description, Date startDate, 
			Date deadline, int ID, Date originalStartDate, Date originalDeadline, 
			Date endingDate, Task oldTask, Task newTask) {
		this.deadline = deadline;
		this.startDate = startDate;
		this.description = description;
		this.command = command;
		this.ID = ID;
		this.oldTask = oldTask;
		this.newTask = newTask;
	}

	public CommandDetails(COMMANDS command, int ID) {
		this.deadline = null;
		this.startDate = null;
		this.description = null;
		this.command = command;
		this.ID = ID;
	}

	// Accessors
	
	public COMMANDS getCommand() {
		return this.command;
	}

	public Date getDeadline() {
		return this.deadline;
	}

	public Date getStartDate() {
		return this.startDate;
	}

	public String getDescription() {
		return this.description;
	}

	public int getID() {
		return this.ID;
	}

	public Task getOldTask() {
		return this.oldTask;
	}

	public Task getNewTask() {
		return this.newTask;
	}

	// Mutators

	public void setCommand(COMMANDS command) {
		this.command = command;
	}

	public Date setDeadline(Date deadline) {
		return this.deadline = deadline;
	}

	public Date setStartDate(Date startDate) {
		return this.startDate = startDate;
	}

	public void setID(int ID) {
		this.ID = ID;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public void setNewTask(Task newTask) {
		this.newTask = newTask;
	}

	public void setOldTask(Task oldTask) {
		this.oldTask = oldTask;
	}

	// Overriding methods
	@Override
	public String toString() {
		String result = "";
		result = "command = " + command + "\nID = " + ID + "\ndescription = " + description + "\nstartDate = "
				+ startDate + "\ndeadline = " + deadline + "\n";
		return result;
	}
}
```
###### control\GSDControl.java
``` java

import parser.Parser;
import parser.InvalidParametersException;
import parser.InvalidTimeDateInputException;

import java.io.IOException;
import java.util.*;
import commandDetail.CommandDetails;
import history.History;
import storage.Storage;
import task.Task;
import ui.Feedback;

/**
 * GSDControl deals with handling of input commands, CRUD of tasks, update of History and update of Storage
 * GSDControl knows the existence of the main components Parser, Task, History and Storage
 * GSDControl knows the existence of stand-alone classes CommandDetails, Task and Feedback 
 * GSDControl does not know the existence of UI
 * GSDControl returns a Feedback Object to UI for displaying
 * 
 * INTERACTIONS OF GSDControl WITH OTHER CLASSES:
 * 
 * Task: Stores an ArrayList of Tasks in GSDControl
 * Parser: Passes input from UI to Parser for parsing into a CommandDetails object which is returned to GSDControl
 * CommandDetails: GSDControl receives CommandDetails objects from Parser. GSDControl sends CommandDetails objects to History
 * History: GSDControl sends and receives CommandDetails objects to and from History respectively
 * Storage: GSDControl sends and receives an ArrayList of Tasks to and from Storage respectively
 * UI: GSDControl returns Feedback objects to UI for displaying 
 * Feedback: GSDControl creates Feedback objects for UI's usage
 */

public class GSDControl {

	private static final String DISPLAY_TASK_NOT_FOUND = ">> Task was not found";
	private static final String DISPLAY_NO_TASKS = ">> No tasks recorded";
	private static final String DISPLAY_NO_FLOATING_TASKS = ">> No Floating Tasks";
	private static final String DISPLAY_NO_EVENTS = ">> No Events";
	private static final String DISPLAY_NO_DEADLINES = ">> No Deadlines";

	private static final String FEEDBACK_WELCOME_MESSAGE = "WELCOME TO GSD!\n";
	private static final String FEEDBACK_ADD = ">> ADDED ";
	private static final String FEEDBACK_SEARCH = ">> SEARCH for ";
	private static final String FEEDBACK_UPDATE = ">> UPDATED ";
	private static final String FEEDBACK_DELETE = ">> DELETED ";
	private static final String FEEDBACK_COMPLETE = ">> COMPLETED ";
	private static final String FEEDBACK_INCOMPLETE = ">> INCOMPLETE ";
	private static final String FEEDBACK_UNDO = ">> Last action undone\n";
	private static final String FEEDBACK_REDO = ">> Last action redone\n";
	private static final String FEEDBACK_ALL = ">> All tasks displayed\n";
	private static final String FEEDBACK_FLOATING = ">> Floating Tasks displayed\n";
	private static final String FEEDBACK_EVENTS = ">> Events displayed\n";
	private static final String FEEDBACK_DEADLINES = ">> Deadlines displayed\n";
	private static final String FEEDBACK_HELP = ">> Called for help!\n";
	private static final String FEEDBACK_SET = ">> File path set to ";
	private static final String FEEDBACK_INVALID_FILE_PATH = ">> ERROR : INVALID FILE PATH\n";
	private static final String FEEDBACK_INVALID_COMMAND = ">> ERROR : INVALID COMMAND\n";
	private static final String FEEDBACK_INVALID_COMMAND_FORMAT = ">> ERROR : INVALID COMMAND FORMAT\n";
	private static final String FEEDBACK_INVALID_TASK_NUMBER = ">> ERROR : INVALID TASK NUMBER\n";
	private static final String FEEDBACK_UNDO_ERROR = ">> ERROR : NOTHING TO UNDO\n";
	private static final String FEEDBACK_REDO_ERROR = ">> ERROR: NOTHING TO REDO\n";
	private static final String FEEDBACK_LOAD_ERROR = ">> ERROR: FAILED TO LOAD FROM CORRUPTED FILE\n";
	private static final String FEEDBACK_FILE_NOT_FOUND = ">> ERROR: FILE TO LOAD DOES NOT EXIST\n";
	private static final String FEEDBACK_INVALID_TIME_DATE_INPUT = ">> ERROR : INVALID DATE/TIME INPUT\n";

	private static final String HELP_COMMANDS = "Add a floating task\n" + "Add a deadline task\n" + "Add an event\n"
			+ "Search for task\n" + "Update a task\n" + "Delete a task\n" + "Mark a task as complete\n"
			+ "Mark a task as incomplete\n" + "Undo last action\n" + "Redo last action\n" + "Display all tasks\n"
			+ "Display floating tasks\n" + "Display events\n" + "Display deadlines\n" + "Set file path\n"
			+ "Exit GSD\n";

	private static final String HELP_SYNTAX = "add <description>\n" + "add <description> by <time AND/OR date>\n"
			+ "add <description> from <start time AND/OR start date> to <end time AND/OR end date>\n"
			+ "search <keyword/day/date>\n" + "update <ID> [Details of floating/event/deadline]\n" + "delete <ID>\n"
			+ "complete <ID>\n" + "incomplete <ID>\n" + "undo\n" + "redo\n" + "all\n" + "floating\n" + "events\n"
			+ "deadlines\n" + "set <file path>\n" + "exit\n";

	private ArrayList<Task> tasks;
	private CommandDetails commandDetails;
	private Storage storage = new Storage();
	private History history = new History();
	private boolean isValidTaskNo = true;

	public GSDControl() {
	}

	/*************************************************************************************************
	 ************************************* INPUT PROCESSING ******************************************
	 *************************************************************************************************/

	public Feedback processInput(String input) {
		try {
			this.commandDetails = Parser.parse(input);
		} catch (NumberFormatException f) {
			//Task Number Invalid or not found
			return new Feedback(null, FEEDBACK_INVALID_TASK_NUMBER, generateInfoBox());
		} catch (InvalidTimeDateInputException g) {
			// Not in the form [Time][Date]
			return new Feedback(null, FEEDBACK_INVALID_TIME_DATE_INPUT, generateInfoBox());
		} catch (InvalidParametersException i) {
			return new Feedback(null, FEEDBACK_INVALID_COMMAND_FORMAT, generateInfoBox());
			/*
			 *	EXAMPLES
			 *	delete 1 potato
			 *  complete 1 potato
			 *	incomplete 1 potato
			 *	undo potato	
			 *	redo potato
			 *	help potato
			 *	all potato
			 *	floating potato
			 *	events potato
			 *	deadlines potato
			 *	exit potato
			 */
		}
		return executeCommand(input);
	}

	private Feedback executeCommand(String input) {
		switch (this.commandDetails.getCommand()) {
		case ADD:
			this.commandDetails.setID(tasks.size());
			return new Feedback(createTask(), FEEDBACK_ADD + commandDetails.getDescription() + "\n", generateInfoBox());
		case DELETE:
			try {
				String taskDescription = tasks.get(commandDetails.getID() - 1).getDescription();
				return new Feedback(deleteTask(commandDetails.getID() - 1), FEEDBACK_DELETE + taskDescription + "\n",
						generateInfoBox());
			} catch (IndexOutOfBoundsException e) {
				isValidTaskNo = false;
				throw new IndexOutOfBoundsException();
			} finally {
				if (!isValidTaskNo) {
					isValidTaskNo = true;
					return new Feedback(displayAllTasks(), FEEDBACK_INVALID_TASK_NUMBER, generateInfoBox());
				}
			}
		case SEARCH:
			String[] temp = input.split(" ");
			String feedbackString = "";
			for (int i = 1; i < temp.length; i++) {
				if(i == temp.length - 1)	{
					feedbackString += temp[i];
				}
				else	{
					feedbackString += temp[i] + " ";
				}
			}
			return new Feedback(searchTask(), FEEDBACK_SEARCH + feedbackString + "\n", generateInfoBox());
		case UPDATE:
			try {
				String taskDescription = tasks.get(commandDetails.getID() - 1).getDescription();
				String commandDetailsDescription = this.commandDetails.getDescription();
				if (this.commandDetails.getDescription() == null || commandDetailsDescription.equals(taskDescription)) {
					return new Feedback(updateTask(commandDetails.getID() - 1),
							FEEDBACK_UPDATE + taskDescription + "\n", generateInfoBox());
				}
				return new Feedback(updateTask(commandDetails.getID() - 1),
						FEEDBACK_UPDATE + taskDescription + " to " + commandDetailsDescription + "\n",
						generateInfoBox());
			} catch (IndexOutOfBoundsException e) {
				isValidTaskNo = false;
				throw new IndexOutOfBoundsException();
			} finally {
				if (!isValidTaskNo) {
					isValidTaskNo = true;
					return new Feedback(displayAllTasks(), FEEDBACK_INVALID_TASK_NUMBER, generateInfoBox());
				}
			}
		case COMPLETE:
			try {
				return new Feedback(completeTask(commandDetails.getID() - 1),
						FEEDBACK_COMPLETE + tasks.get(this.commandDetails.getID() - 1).getDescription() + "\n",
						generateInfoBox());
			} catch (IndexOutOfBoundsException e) {
				isValidTaskNo = false;
				throw new IndexOutOfBoundsException();
			} finally {
				if (!isValidTaskNo) {
					isValidTaskNo = true;
					return new Feedback(displayAllTasks(), FEEDBACK_INVALID_TASK_NUMBER, generateInfoBox());
				}
			}
		case INCOMPLETE:
			try {
				return new Feedback(incompleteTask(commandDetails.getID() - 1),
						FEEDBACK_INCOMPLETE + tasks.get(this.commandDetails.getID() - 1).getDescription() + "\n",
						generateInfoBox());
			} catch (IndexOutOfBoundsException e) {
				isValidTaskNo = false;
				throw new IndexOutOfBoundsException();
			} finally {
				if (!isValidTaskNo) {
					isValidTaskNo = true;
					return new Feedback(displayAllTasks(), FEEDBACK_INVALID_TASK_NUMBER, generateInfoBox());
				}
			}
		case REDO:
			this.commandDetails = history.redo();
			if (this.commandDetails == null) {
				return new Feedback(displayAllTasks(), FEEDBACK_REDO_ERROR, generateInfoBox());
			}
			return new Feedback(redoLastAction(), FEEDBACK_REDO, generateInfoBox());
		case UNDO:
			this.commandDetails = history.undo();
			if (this.commandDetails == null) {
				return new Feedback(displayAllTasks(), FEEDBACK_UNDO_ERROR, generateInfoBox());
			}
			return new Feedback(undoLastAction(), FEEDBACK_UNDO, generateInfoBox());
		case ALL:
			return new Feedback(displayAllTasks(), FEEDBACK_ALL, generateInfoBox());
		case FLOATING:
			return new Feedback(displayFloatingTasks(), FEEDBACK_FLOATING, generateInfoBox());
		case EVENTS:
			return new Feedback(displayEvents(), FEEDBACK_EVENTS, generateInfoBox());
		case DEADLINES:
			return new Feedback(displayDeadlines(), FEEDBACK_DEADLINES, generateInfoBox());
		case HELP:
			return new Feedback(null, FEEDBACK_HELP, generateInfoBox(), HELP_COMMANDS, HELP_SYNTAX);
		case EXIT:
			return null;
		case SET:
			boolean isValidFilePath = setFilePath();
			if (isValidFilePath) {
				return new Feedback(null, FEEDBACK_SET + commandDetails.getDescription() + "\n", generateInfoBox());
			} else {
				return new Feedback(null, FEEDBACK_INVALID_FILE_PATH, generateInfoBox());
			}
		default:
			return new Feedback(displayAllTasks(), FEEDBACK_INVALID_COMMAND, generateInfoBox());

		}
	}

	/*************************************************************************************************
	 ******************************************* UI **************************************************
	 *************************************************************************************************/

	public Feedback loadFromFile() {
		try	{
		tasks = storage.load();
		} catch (IOException e)	{	//File does not exist
			tasks = new ArrayList<Task>();
			return new Feedback(DISPLAY_NO_TASKS, FEEDBACK_FILE_NOT_FOUND, generateInfoBox());
		}

		if (tasks == null) {	//File contains corrupted info
			tasks = new ArrayList<Task>();
			return new Feedback(DISPLAY_NO_TASKS, FEEDBACK_LOAD_ERROR, generateInfoBox());
		}
		return new Feedback(displayAllTasks(), FEEDBACK_WELCOME_MESSAGE, generateInfoBox());
	}

	/*************************************************************************************************
	 ******************************************* CRUD ************************************************
	 *************************************************************************************************/

	private String createTask() {
		Task task = new Task(this.commandDetails);
		tasks.add(task);
		this.commandDetails.setNewTask(task);
		sendToHistory();
		storage.save(tasks);
		return displayAllTasks();
	}

	private String searchTask() {
		String search = "";
		String searchIncomplete = "";
		String searchComplete = "";

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).contains(commandDetails) && !tasks.get(i).isComplete()) {
				searchIncomplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).contains(commandDetails) && tasks.get(i).isComplete()) {
				searchComplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		if (!searchIncomplete.isEmpty()) {
			searchIncomplete = "\t\tINCOMPLETED\n\n" + searchIncomplete;
		}

		if (!searchComplete.isEmpty()) {
			searchComplete = "\t\tCOMPLETED\n\n" + searchComplete;
		}

		search = searchIncomplete + searchComplete;

		if (search.isEmpty()) {
			search = DISPLAY_TASK_NOT_FOUND;
		}
		return search;
	}

	private String updateTask(int ID) {
		CommandDetails oldDetails = generateDetails();
		Task oldTask = new Task(oldDetails);
		oldDetails.setOldTask(oldTask);
		tasks.get(ID).updateDetails(commandDetails);
		Task newTask = new Task(generateDetails());
		oldDetails.setNewTask(newTask);
		this.commandDetails = oldDetails;
		sendToHistory();
		storage.save(tasks);
		return displayAllTasks();
	}

	private String deleteTask(int ID) {
		sendToHistory();
		tasks.remove(ID);
		storage.save(tasks);
		return displayAllTasks();
	}

	private String completeTask(int ID) {
		tasks.get(ID).markAsComplete();
		this.commandDetails.setNewTask(tasks.get(ID));
		sendToHistory();
		storage.save(tasks);
		return displayAllTasks();
	}

	private String incompleteTask(int ID) {
		tasks.get(ID).markAsIncomplete();
		this.commandDetails.setNewTask(tasks.get(ID));
		sendToHistory();
		storage.save(tasks);
		return displayAllTasks();
	}

	private boolean setFilePath() {
		return storage.setFilePath(this.commandDetails.getDescription());
	}

	/*************************************************************************************************
	 ******************************************* UNDO/REDO *******************************************
	 *************************************************************************************************/

	private String undoLastAction() {
		return reverseAndExecuteHistoryCommand(this.commandDetails.getID());
	}

	private String redoLastAction() {
		return executeHistoryCommand();
	}

	private String executeHistoryCommand() {
		switch (this.commandDetails.getCommand()) {
		case ADD:
			return undoRedoCreateTask(this.commandDetails.getID(), this.commandDetails.getNewTask());
		case DELETE:
			searchForID();
			return undoRedoDeleteTask(this.commandDetails.getID());
		case UPDATE:
			searchRedoID();
			return redoUpdateTask(this.commandDetails.getID(), this.commandDetails.getNewTask());
		case COMPLETE:
			searchForID();
			return undoRedoCompleteTask(commandDetails.getID());
		case INCOMPLETE:
			searchForID();
			return undoRedoIncompleteTask(commandDetails.getID());
		default:
			return null;
		}
	}

	private String reverseAndExecuteHistoryCommand(int ID) {
		switch (this.commandDetails.getCommand()) {
		case ADD:
			this.commandDetails = reverseAdd();
			return undoRedoDeleteTask(this.commandDetails.getID());
		case DELETE:
			this.commandDetails = reverseDelete();
			return undoRedoCreateTask(this.commandDetails.getID(), this.commandDetails.getNewTask());
		case UPDATE:
			searchForID();
			return undoUpdateTask(this.commandDetails.getID(), this.commandDetails.getOldTask());
		case COMPLETE:
			this.commandDetails = reverseComplete();
			return undoRedoIncompleteTask(this.commandDetails.getID());
		case INCOMPLETE:
			this.commandDetails = reverseIncomplete();
			return undoRedoCompleteTask(this.commandDetails.getID());
		default:
			return null;

		}
	}

	private String undoRedoCreateTask(int ID, Task task) {
		tasks.add(ID, task);
		storage.save(tasks);
		return displayAllTasks();
	}

	private String undoRedoDeleteTask(int ID) {
		tasks.remove(ID);
		storage.save(tasks);
		return displayAllTasks();
	}

	private String undoUpdateTask(int ID, Task oldTask) {
		tasks.get(ID).setAs(oldTask);
		storage.save(tasks);
		return displayAllTasks();
	}

	private String redoUpdateTask(int ID, Task newTask) {
		tasks.get(ID).setAs(newTask);
		storage.save(tasks);
		return displayAllTasks();
	}

	private String undoRedoCompleteTask(int ID) {
		tasks.get(ID).markAsComplete();
		storage.save(tasks);
		return displayAllTasks();
	}

	private String undoRedoIncompleteTask(int ID) {
		tasks.get(ID).markAsIncomplete();
		storage.save(tasks);
		return displayAllTasks();
	}

	private CommandDetails reverseAdd() {
		searchForID();
		return new CommandDetails(CommandDetails.COMMANDS.DELETE, this.commandDetails.getID());
	}

	private CommandDetails reverseDelete() {
		return new CommandDetails(CommandDetails.COMMANDS.ADD, this.commandDetails.getDescription(),
				this.commandDetails.getStartDate(), this.commandDetails.getDeadline(), this.commandDetails.getID(),
				this.commandDetails.getNewTask());
	}

	private CommandDetails reverseComplete() {
		searchForID();
		return new CommandDetails(CommandDetails.COMMANDS.INCOMPLETE, this.commandDetails.getID());
	}

	private CommandDetails reverseIncomplete() {
		searchForID();
		return new CommandDetails(CommandDetails.COMMANDS.COMPLETE, this.commandDetails.getID());
	}

	private void searchForID() {
		for (int i = 0; i < tasks.size(); i++) {
			if (this.commandDetails.getNewTask().matches(tasks.get(i))) {
				this.commandDetails.setID(i);
			}
		}
	}

	private void searchRedoID() {
		for (int i = 0; i < tasks.size(); i++) {
			if (this.commandDetails.getOldTask().matches(tasks.get(i))) {
				this.commandDetails.setID(i);
			}
		}
	}

	/*************************************************************************************************
	 ******************************************* HISTORY *********************************************
	 *************************************************************************************************/

	private void sendToHistory() {
		switch (this.commandDetails.getCommand()) {
		case ADD:
			history.insert(this.commandDetails);
			break;
		case DELETE:
			history.insert(generateDetails());
			break;
		case UPDATE:
			history.insert(this.commandDetails);
			break;
		case COMPLETE:
			history.insert(this.commandDetails);
			break;
		case INCOMPLETE:
			history.insert(this.commandDetails);
			break;
		default:
			break;
		}
	}

	/**
	 * Creates a CommandDetails object that matches the current CommandDetails
	 * object in GSDControl. This method is only used for DELETE and UPDATE
	 * Commands due to the nature of the Commands i.e. Requires history of both
	 * old and new versions of Tasks.
	 */
	private CommandDetails generateDetails() {
		Task task = tasks.get(this.commandDetails.getID() - 1);
		switch (this.commandDetails.getCommand()) {
		case DELETE:
			return new CommandDetails(CommandDetails.COMMANDS.DELETE, task.getDescription(), task.getStartDate(),
					task.getDeadline(), this.commandDetails.getID() - 1, task);
		case UPDATE:
			return new CommandDetails(CommandDetails.COMMANDS.UPDATE, task.getDescription(), task.getStartDate(),
					task.getDeadline(), this.commandDetails.getID() - 1);
		default:
			return null;
		}
	}

	/*************************************************************************************************
	 ******************************************* DISPLAY *********************************************
	 *************************************************************************************************/

	private String displayAllTasks() {
		Collections.sort(tasks);
		String displayAll = "";
		String displayIncomplete = "";
		String displayComplete = "";

		for (int i = 0; i < tasks.size(); i++) {
			if (!tasks.get(i).isComplete())
				displayIncomplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
		}

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isComplete())
				displayComplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
		}

		if (!displayIncomplete.isEmpty()) {
			displayIncomplete = "\t\tINCOMPLETED\n\n" + displayIncomplete;
		}

		if (!displayComplete.isEmpty()) {
			displayComplete = "\t\tCOMPLETED\n\n" + displayComplete;
		}

		displayAll = displayIncomplete + displayComplete;

		if (displayAll.isEmpty()) {
			return displayAll = DISPLAY_NO_TASKS;
		}

		return displayAll;
	}

	private String displayFloatingTasks() {
		Collections.sort(tasks);
		String floating = "";
		String floatingIncomplete = "";
		String floatingComplete = "";

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isFloating() && !tasks.get(i).isComplete()) {
				floatingIncomplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isFloating() && tasks.get(i).isComplete()) {
				floatingComplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		if (!floatingIncomplete.isEmpty()) {
			floatingIncomplete = "\t\tINCOMPLETED\n\n" + floatingIncomplete;
		}

		if (!floatingComplete.isEmpty()) {
			floatingComplete = "\t\tCOMPLETED\n\n" + floatingComplete;
		}

		floating = floatingIncomplete + floatingComplete;

		if (floating.isEmpty()) {
			return floating = DISPLAY_NO_FLOATING_TASKS;
		}
		return floating;
	}

	private String displayEvents() {
		Collections.sort(tasks);
		String events = "";
		String eventsIncomplete = "";
		String eventsComplete = "";

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isEvent() && !tasks.get(i).isComplete()) {
				eventsIncomplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isEvent() && tasks.get(i).isComplete()) {
				eventsComplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		if (!eventsIncomplete.isEmpty()) {
			eventsIncomplete = "\t\tINCOMPLETED\n\n" + eventsIncomplete;
		}

		if (!eventsComplete.isEmpty()) {
			eventsComplete = "\t\tCOMPLETED\n\n" + eventsComplete;
		}

		events = eventsIncomplete + eventsComplete;

		if (events.isEmpty()) {
			return events = DISPLAY_NO_EVENTS;
		}
		return events;
	}

	private String displayDeadlines() {
		Collections.sort(tasks);
		String deadlines = "";
		String deadlinesIncomplete = "";
		String deadlinesComplete = "";

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isDeadline() && !tasks.get(i).isComplete()) {
				deadlinesIncomplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isDeadline() && tasks.get(i).isComplete()) {
				deadlinesComplete += i + 1 + ". " + tasks.get(i).toString() + "\n";
			}
		}

		if (!deadlinesIncomplete.isEmpty()) {
			deadlinesIncomplete = "\t\tINCOMPLETED\n\n" + deadlinesIncomplete;
		}

		if (!deadlinesComplete.isEmpty()) {
			deadlinesComplete = "\t\tCOMPLETED\n\n" + deadlinesComplete;
		}

		deadlines = deadlinesIncomplete + deadlinesComplete;

		if (deadlines.isEmpty()) {
			return deadlines = DISPLAY_NO_DEADLINES;
		}
		return deadlines;
	}

	private String generateInfoBox() {
		int floating = 0, events = 0, deadlines = 0, totalTasks = tasks.size();

		for (int i = 0; i < tasks.size(); i++) {
			if (tasks.get(i).isDeadline()) {
				deadlines++;
			}
			if (tasks.get(i).isEvent()) {
				events++;
			}
			if (tasks.get(i).isFloating()) {
				floating++;
			}

		}
		return "Floating Tasks = " + floating + "\nEvents = " + events + "\nDeadlines = " + deadlines
				+ "\nTotal No. of Tasks = " + totalTasks + "\n";
	}
}
```
###### control\testGSDControl.java
``` java

import static org.junit.Assert.*;

import java.io.File;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import ui.Feedback;

public class testGSDControl {

	private static final String DISPLAY_TASK_NOT_FOUND = ">> Task was not found";
	private static final String DISPLAY_NO_TASKS = ">> No tasks recorded";
	private static final String DISPLAY_NO_FLOATING_TASKS = ">> No Floating Tasks";
	private static final String DISPLAY_NO_EVENTS = ">> No Events";
	private static final String DISPLAY_NO_DEADLINES = ">> No Deadlines";

	private static final String FEEDBACK_WELCOME_MESSAGE = "WELCOME TO GSD!\n";
	private static final String FEEDBACK_ADD = ">> ADDED ";
	private static final String FEEDBACK_SEARCH = ">> SEARCH for ";
	private static final String FEEDBACK_UPDATE = ">> UPDATED ";
	private static final String FEEDBACK_DELETE = ">> DELETED ";
	private static final String FEEDBACK_COMPLETE = ">> COMPLETED ";
	private static final String FEEDBACK_INCOMPLETE = ">> INCOMPLETE ";
	private static final String FEEDBACK_UNDO = ">> Last action undone\n";
	private static final String FEEDBACK_REDO = ">> Last action redone\n";
	private static final String FEEDBACK_ALL = ">> All tasks displayed\n";
	private static final String FEEDBACK_FLOATING = ">> Floating Tasks displayed\n";
	private static final String FEEDBACK_EVENTS = ">> Events displayed\n";
	private static final String FEEDBACK_DEADLINES = ">> Deadlines displayed\n";
	private static final String FEEDBACK_HELP = ">> Called for help!\n";
	private static final String FEEDBACK_SET = ">> File path set to ";
	private static final String FEEDBACK_INVALID_FILE_PATH = ">> ERROR : INVALID FILE PATH\n";
	private static final String FEEDBACK_INVALID_COMMAND_FORMAT = ">> ERROR : INVALID COMMAND FORMAT\n";
	private static final String FEEDBACK_INVALID_TASK_NUMBER = ">> ERROR : INVALID TASK NUMBER\n";
	private static final String FEEDBACK_UNDO_ERROR = ">> ERROR : NOTHING TO UNDO\n";
	private static final String FEEDBACK_REDO_ERROR = ">> ERROR: NOTHING TO REDO\n";
	private static final String FEEDBACK_FILE_NOT_FOUND = ">> ERROR: FILE TO LOAD DOES NOT EXIST\n";
	private static final String FEEDBACK_INVALID_TIME_DATE_INPUT = ">> ERROR : INVALID DATE/TIME INPUT\n";

	private static final String HELP_COMMANDS = "Add a floating task\n" + "Add a deadline task\n" + "Add an event\n"
			+ "Search for task\n" + "Update a task\n" + "Delete a task\n" + "Mark a task as complete\n"
			+ "Mark a task as incomplete\n" + "Undo last action\n" + "Redo last action\n" + "Display all tasks\n"
			+ "Display floating tasks\n" + "Display events\n" + "Display deadlines\n" + "Set file path\n"
			+ "Exit GSD\n";

	private static final String HELP_SYNTAX = "add <description>\n" + "add <description> by <time AND/OR date>\n"
			+ "add <description> from <start time AND/OR start date> to <end time AND/OR end date>\n"
			+ "search <keyword/day/date>\n" + "update <ID> [Details of floating/event/deadline]\n" + "delete <ID>\n"
			+ "complete <ID>\n" + "incomplete <ID>\n" + "undo\n" + "redo\n" + "all\n" + "floating\n" + "events\n"
			+ "deadlines\n" + "set <file path>\n" + "exit\n";

	private static final String PATH_CURRENT = System.getProperty("user.dir") + File.separatorChar;
	private static final String FILENAME = "saveFile.txt";

	private static final String DEFAULT_TASK = "\t\tINCOMPLETED\n\n1. TASK" + "\nStart Date: -" + "\nDeadline: -" + "\n\n";
	private static final String DEFAULT_TASK_COMPLETED = "\t\tCOMPLETED\n\n1. TASK" + "\nStart Date: -" + "\nDeadline: -" + "\n\n";
	private static final String DEFAULT_TASK_DESCRIPTION = "TASK\n";
	private static final String UPDATED_TASK = "\t\tINCOMPLETED\n\n1. NOTHING" + "\nStart Date: -" + "\nDeadline: -" + "\n\n";
	private static final String INFO_BOX = "Floating Tasks = 1" + "\nEvents = 0" + "\nDeadlines = 0"
			+ "\nTotal No. of Tasks = 1" + "\n";
	private static final String INFO_BOX_EVENTS = "Floating Tasks = 0" + "\nEvents = 1" + "\nDeadlines = 0"
			+ "\nTotal No. of Tasks = 1" + "\n";
	private static final String INFO_BOX_DEADLINES = "Floating Tasks = 0" + "\nEvents = 0" + "\nDeadlines = 1"
			+ "\nTotal No. of Tasks = 1" + "\n";

	String input;
	Feedback feedback;
	Feedback check;
	GSDControl gsd = new GSDControl();

	@Before
	public void setUp() {
		gsd.loadFromFile();
		input = "set " + PATH_CURRENT + FILENAME;
		gsd.processInput(input);

	}

	@Test
	public void testCreateTask() {
		input = "add TASK";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_ADD + DEFAULT_TASK_DESCRIPTION, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testSearchTask() {
		input = "add TASK";
		gsd.processInput(input);
		input = "search TASK";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_SEARCH + DEFAULT_TASK_DESCRIPTION, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testSearchNothing() {
		input = "search TASK";
		check = new Feedback(DISPLAY_TASK_NOT_FOUND, FEEDBACK_SEARCH + "TASK\n", INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testUpdateTask() {
		input = "add TASK";
		gsd.processInput(input);
		input = "update 1 NOTHING";
		check = new Feedback(UPDATED_TASK, FEEDBACK_UPDATE + "TASK to NOTHING\n", INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testUpdateNothing() {
		input = "update 1 NOTHING";
		gsd.processInput(input);
		input = "search TASK";
		check = new Feedback(DISPLAY_TASK_NOT_FOUND, FEEDBACK_SEARCH + "TASK\n", INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testDeleteTask() {
		input = "add TASK";
		gsd.processInput(input);
		input = "delete 1";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_DELETE + "TASK\n", INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testDeleteNothing() {
		input = "delete 1";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_INVALID_TASK_NUMBER, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testComplete() {
		input = "add TASK";
		gsd.processInput(input);
		input = "complete 1";
		check = new Feedback(DEFAULT_TASK_COMPLETED, FEEDBACK_COMPLETE + "TASK\n", INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testCompleteNothing() {
		input = "complete 1";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_INVALID_TASK_NUMBER, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testIncomplete() {
		input = "add TASK";
		gsd.processInput(input);
		input = "incomplete 1";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_INCOMPLETE + "TASK\n", INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testIncompleteNothing() {
		input = "incomplete 1";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_INVALID_TASK_NUMBER, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testUndo() {
		input = "add TASK";
		gsd.processInput(input);
		input = "undo";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_UNDO, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testUndoNothing() {
		input = "undo";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_UNDO_ERROR, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testRedo() {
		input = "add TASK";
		gsd.processInput(input);
		input = "undo";
		gsd.processInput(input);
		input = "redo";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_REDO, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testRedoNothing() {
		input = "redo";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_REDO_ERROR, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testAll() {
		input = "add TASK";
		gsd.processInput(input);
		input = "all";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_ALL, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testNoAll() {
		input = "all";
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_ALL, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testNoFloating() {
		input = "floating";
		check = new Feedback(DISPLAY_NO_FLOATING_TASKS, FEEDBACK_FLOATING, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testFloating() {
		input = "add TASK";
		gsd.processInput(input);
		input = "floating";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_FLOATING, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testNoEvents() {
		input = "events";
		check = new Feedback(DISPLAY_NO_EVENTS, FEEDBACK_EVENTS, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testEvents() {
		input = "add TASK FROM today TO tomorrow";
		gsd.processInput(input);
		input = "events";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_EVENTS, INFO_BOX_EVENTS);
		feedback = gsd.processInput(input);
		assertNotEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testDeadlines() {
		input = "add TASK BY tomorrow";
		gsd.processInput(input);
		input = "deadlines";
		check = new Feedback(DEFAULT_TASK, FEEDBACK_DEADLINES, INFO_BOX_DEADLINES);
		feedback = gsd.processInput(input);
		assertNotEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testNoDeadlines() {
		input = "deadlines";
		check = new Feedback(DISPLAY_NO_DEADLINES, FEEDBACK_DEADLINES, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testHelp() {
		input = "help";
		check = new Feedback(null, FEEDBACK_HELP, INFO_BOX, HELP_COMMANDS, HELP_SYNTAX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getHelpCommandString(), check.getHelpCommandString());
		assertEquals(feedback.getHelpSyntaxString(), check.getHelpSyntaxString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testSet() {
		input = "set " + PATH_CURRENT + FILENAME;
		check = new Feedback(null, FEEDBACK_SET + PATH_CURRENT + FILENAME + "\n", INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testSetFail() {
		input = "set LOLKAPPAPRIDE";
		check = new Feedback(null, FEEDBACK_INVALID_FILE_PATH, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@Test
	public void testLoadFromFile() {
		input = "add TASK";
		gsd.processInput(input);
		check = new Feedback(DEFAULT_TASK, FEEDBACK_WELCOME_MESSAGE, INFO_BOX);
		feedback = gsd.loadFromFile();
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
	}
	
	@Test
	public void testLoadFromFileNothing() {
		check = new Feedback(DISPLAY_NO_TASKS, FEEDBACK_FILE_NOT_FOUND, INFO_BOX);
		feedback = gsd.loadFromFile();
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}
	
	@Test
	public void testInvalidTimeDateInput()	{
		input = "add TASK by today 7pm";
		check = new Feedback(null, FEEDBACK_INVALID_TIME_DATE_INPUT, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "add TASK";
		gsd.processInput(input);
		input = "update 1 TASK by today 7pm";
		check = new Feedback(null, FEEDBACK_INVALID_TIME_DATE_INPUT, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertEquals(feedback.getInfoString(), check.getInfoString());
		input = "delete 1";
		gsd.processInput(input);
		input = "search TASK by today 7pm";
		check = new Feedback(null, FEEDBACK_INVALID_TIME_DATE_INPUT, INFO_BOX);
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		
	}

	@Test
	public void testInvalidCommandFormat() {
		check = new Feedback(null, FEEDBACK_INVALID_COMMAND_FORMAT, INFO_BOX);
		input = "add";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "delete";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "search";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "update";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "complete";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "incomplete";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "undo LOLKAPPAPRIDE";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "redo LOLKAPPAPRIDE";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "all LOLKAPPAPRIDE";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "floating LOLKAPPAPRIDE";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "events LOLKAPPAPRIDE";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "deadlines LOLKAPPAPRIDE";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "help LOLKAPPAPRIDE";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
		input = "set";
		feedback = gsd.processInput(input);
		assertEquals(feedback.getDisplayString(), check.getDisplayString());
		assertEquals(feedback.getFeedbackString(), check.getFeedbackString());
		assertNotEquals(feedback.getInfoString(), check.getInfoString());
	}

	@After
	public void tearDown() {
		File file = new File(PATH_CURRENT + FILENAME);
		file.delete();
	}
}
```
###### task\Task.java
``` java

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import commandDetail.CommandDetails;

/**
 * Task is a stand-alone object used in GetStuffDone
 * Task does not know the existence of UI, GSDControl, Parser, History and Storage
 * Task knows the existence of CommandDetails
 * 
 * INTERACTIONS OF Task WITH OTHER CLASSES:
 * 
 * GSDControl: An ArrayList of Tasks are stored in GSDControl
 * Storage: The ArrayList of Tasks from GSDControl is passed to Storage for saving and loading purposes
 * CommandDetails: A Task is created from a CommandDetails object
 */

public class Task implements Comparable<Task> {

	private String description;
	private Date startDate;
	private Date deadline;
	private Boolean isComplete;

	// Constructors

	// Default
	public Task() {
		description = null;
		startDate = null;
		deadline = null;
		isComplete = new Boolean(false);

	}

	public Task(CommandDetails details) {
		this.description = details.getDescription();
		this.startDate = details.getStartDate();
		this.deadline = details.getDeadline();
		this.isComplete = false;
	}

	// Mutators

	public void setDescription(String description) {
		this.description = description;
	}

	public void setStartDate(Date startDate) {
		this.startDate = startDate;
	}

	public void setDeadline(Date deadline) {
		this.deadline = deadline;
	}

	public void setIsComplete(boolean isComplete) {
		this.isComplete = isComplete;
	}

	// Accessors

	public String getDescription() {
		return this.description;
	}

	public Date getStartDate() {
		return this.startDate;
	}

	public Date getDeadline() {
		return this.deadline;
	}

	public Boolean isComplete() {
		return this.isComplete;
	}

	public boolean isEvent() {
		return (this.startDate != null && this.deadline != null);
	}

	public boolean isDeadline() {
		return (this.startDate == null && this.deadline != null);
	}

	public boolean isFloating() {
		return (this.startDate == null && this.deadline == null);
	}

	// Behavioural methods

	public void updateDetails(CommandDetails details) {

		this.description = details.getDescription();
		this.startDate = details.getStartDate();
		this.deadline = details.getDeadline();
	}

	public void setAs(Task task) {

		this.description = task.getDescription();
		this.startDate = task.getStartDate();
		this.deadline = task.getDeadline();
	}

	public void markAsComplete() {
		isComplete = Boolean.TRUE;
	}

	public void markAsIncomplete() {
		isComplete = Boolean.FALSE;
	}

	public boolean matches(Task o) {
		return (getDescription() == o.getDescription() && getStartDate() == o.getStartDate()
				&& getDeadline() == o.getDeadline() && isComplete() == o.isComplete());
	}

	public boolean contains(CommandDetails details) {

		Calendar taskStartDateCal = null;
		if (this.startDate != null) {
			taskStartDateCal = Calendar.getInstance();
			taskStartDateCal.setTime(this.startDate);
		}

		Calendar taskDeadlineCal = null;
		if (this.deadline != null) {
			taskDeadlineCal = Calendar.getInstance();
			taskDeadlineCal.setTime(this.deadline);
		}

		Calendar detailsStartDateCal = null;
		if (details.getStartDate() != null) {
			detailsStartDateCal = Calendar.getInstance();
			detailsStartDateCal.setTime(details.getStartDate());
		}

		Calendar detailsDeadlineCal = null;
		if (details.getDeadline() != null) {
			detailsDeadlineCal = Calendar.getInstance();
			detailsDeadlineCal.setTime(details.getDeadline());
		}

		if (details.getDescription() != null && this.description.contains(details.getDescription())) {
			return true;
		}

		if (details.getStartDate() != null && taskStartDateCal != null) {
			if (taskStartDateCal.get(Calendar.DAY_OF_YEAR) == (detailsStartDateCal.get(Calendar.DAY_OF_YEAR))) {
				return true;
			}
		}

		if (details.getDeadline() != null && taskDeadlineCal != null) {
			if (taskDeadlineCal.get(Calendar.DAY_OF_YEAR) == (detailsDeadlineCal.get(Calendar.DAY_OF_YEAR))) {
				return true;
			}
		}
		return false;
	}

	// Overriding methods

	@Override
	public String toString() {
		DateFormat df = new SimpleDateFormat("hh:mma dd/MMM/yyyy ");

		String start, end;

		if (startDate == null) {
			start = "";
		} else {
			start = df.format(startDate);
		}

		if (deadline == null) {
			end = "";
		} else {
			end = df.format(deadline);
		}
		if (isFloating()) {
			return (description + "\nStart Date: -\nDeadline: -\n");
		} else if (isEvent()) {
			return (description + "\nStart Date: " + start + "\nDeadline: " + end + "\n");
		} else if (isDeadline()) {
			return description + "\nStart Date: -\nDeadline: " + end + "\n";
		}
		return null;
	}

	@Override
	public int compareTo(Task o) {
		if (isFloating() == true && o.isFloating() == true) {
			return 0;
		}
		if (isFloating() == true && o.isFloating() == false) {
			return 1;
		}
		if (isFloating() == false && o.isFloating() == true) {
			return -1;
		}
		return getDeadline().compareTo(o.getDeadline());
	}
}
```
###### ui\Feedback.java
``` java

/**
 * Feedback is a stand-alone object used in GetStuffDone
 * Feedback does not know the existence of any class
 * 
 * INTERACTIONS OF Feedback WITH OTHER CLASSES:
 * 
 * GSDControl: Created by GSDControl and returned to UI for display of relevant information
 * UI: Received by UI from GSDControl for display of relevant information
 */

public class Feedback {
	private String displayString = null;
	private String feedbackString = null;
	private String infoString = null;
	private String helpCommandString = null;
	private String helpSyntaxString = null;

	public Feedback(String displayString, String feedbackString, String infoString) {
		this.displayString = displayString;
		this.feedbackString = feedbackString;
		this.infoString = infoString;
	}

	public Feedback(String displayString, String feedbackString, String infoString, String helpCommandString,
			String helpSyntaxString) {
		this.displayString = displayString;
		this.feedbackString = feedbackString;
		this.infoString = infoString;
		this.helpCommandString = helpCommandString;
		this.helpSyntaxString = helpSyntaxString;
	}

	// Mutators

	public void setDisplayString(String displayString) {
		this.displayString = displayString;
	}

	public void setFeedbackString(String feedbackString) {
		this.feedbackString = feedbackString;
	}

	public void setInfoString(String infoString) {
		this.infoString = infoString;
	}

	// Accessors

	public String getDisplayString() {
		return displayString;
	}

	public String getFeedbackString() {
		return feedbackString;
	}

	public String getInfoString() {
		return infoString;
	}

	public String getHelpSyntaxString() {
		return helpSyntaxString;
	}

	public String getHelpCommandString() {
		return helpCommandString;
	}
}
```
